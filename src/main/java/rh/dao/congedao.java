package rh.dao;

import rh.model.Conge;
import rh.utils.ConnexionDB; // Assuming this is your DB connection class

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;
import java.sql.Date; // For converting LocalDate to java.sql.Date

public class congedao {

    public void ajouterConge(Conge conge) throws SQLException {
        // ID_CONGE is VARCHAR2(10) and not auto-generated by sequence here.
        // It's crucial to generate it in Java or use a DB sequence and retrieve it.
        // For simplicity, let's assume it's generated *before* calling this method.
        // Or, if it's auto-generated in the DB with a trigger or sequence, ensure you retrieve it.

        // NB_JOURS and DATE_SOUMISSION will be handled by the database (or calculated in Java)

        String sql = "INSERT INTO Conge (ID_CONGE, MATRICULE_EMPLOYE, DATE_DEBUT, DATE_FIN, TYPE_CONGE, JUSTIFICATIF, STATUT, DATE_SOUMISSION) VALUES (?, ?, ?, ?, ?, ?, ?, SYSDATE)";

        try (Connection conn = ConnexionDB.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql)) { // No Statement.RETURN_GENERATED_KEYS if ID_CONGE is not DB-generated auto-incrementing INT

            ps.setString(1, conge.getIdConge()); // Assuming ID_CONGE is set before calling this method
            ps.setString(2, conge.getMatriculeEmploye());
            ps.setDate(3, Date.valueOf(conge.getDateDebut())); // Convert LocalDate to java.sql.Date
            ps.setDate(4, Date.valueOf(conge.getDateFin()));   // Convert LocalDate to java.sql.Date
            ps.setString(5, conge.getTypeConge());
            ps.setString(6, conge.getJustificatif());
            ps.setString(7, conge.getStatut()); // Default 'En attente'

            ps.executeUpdate();
            // If ID_CONGE is generated by a trigger in DB, you might need to query it back.
            // If it's a sequence, you'd typically select sequence.NEXTVAL before insert.
        }
    }

    public Conge getCongeById(String idConge) throws SQLException {
        Conge conge = null;
        String sql = "SELECT ID_CONGE, MATRICULE_EMPLOYE, DATE_DEBUT, DATE_FIN, TYPE_CONGE, JUSTIFICATIF, STATUT FROM Conge WHERE ID_CONGE = ?";
        try (Connection conn = ConnexionDB.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setString(1, idConge);
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    conge = mapResultSetToConge(rs);
                }
            }
        }
        return conge;
    }
    //Récupérer toutes les demandes de congé
    //    Cette méthode est essentielle pour le tableau de bord RH, car elle leur permettra de voir l'ensemble des demandes.
    public List<Conge> getAllConges() throws SQLException {
        List<Conge> conges = new ArrayList<>();
        // Trie les demandes : d'abord par statut (ex: 'En attente' en premier), puis par date de début décroissante
        String sql = "SELECT ID_CONGE, MATRICULE_EMPLOYE, DATE_DEBUT, DATE_FIN, TYPE_CONGE, JUSTIFICATIF, STATUT FROM Conge ORDER BY STATUT ASC, DATE_DEBUT DESC";
        try (Connection conn = ConnexionDB.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql);
             ResultSet rs = ps.executeQuery()) { // Pas de paramètres pour cette requête

            while (rs.next()) {
                conges.add(mapResultSetToConge(rs)); // Réutilise la méthode d'aide existante
            }
        }
        return conges;
    }
//Mettre à jour le statut d'une demande de congé
//    Cette méthode sera utilisée lorsque les RH approuvent ou refusent une demande.

    public void updateCongeStatut(Conge conge) throws SQLException {
        // Met à jour uniquement le statut basé sur l'ID du congé
        String sql = "UPDATE Conge SET STATUT = ? WHERE ID_CONGE = ?";
        try (Connection conn = ConnexionDB.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql)) {

            ps.setString(1, conge.getStatut()); // Le nouveau statut ('Approuvé', 'Refusé')
            ps.setString(2, conge.getIdConge()); // Identifie la demande de congé spécifique par son ID

            ps.executeUpdate();
        }
    }


    public List<Conge> getCongesByMatriculeEmploye(String matriculeEmploye) throws SQLException {
        List<Conge> conges = new ArrayList<>();
        String sql = "SELECT ID_CONGE, MATRICULE_EMPLOYE, DATE_DEBUT, DATE_FIN, TYPE_CONGE, JUSTIFICATIF, STATUT FROM Conge WHERE MATRICULE_EMPLOYE = ?";
        try (Connection conn = ConnexionDB.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setString(1, matriculeEmploye);
            try (ResultSet rs = ps.executeQuery()) {
                while (rs.next()) {
                    conges.add(mapResultSetToConge(rs));
                }
            }
        }
        return conges;
    }


    private Conge mapResultSetToConge(ResultSet rs) throws SQLException {
        Conge conge = new Conge();
        conge.setIdConge(rs.getString("ID_CONGE"));
        conge.setMatriculeEmploye(rs.getString("MATRICULE_EMPLOYE"));
        conge.setDateDebut(rs.getDate("DATE_DEBUT").toLocalDate());
        conge.setDateFin(rs.getDate("DATE_FIN").toLocalDate());
        conge.setTypeConge(rs.getString("TYPE_CONGE"));
        conge.setJustificatif(rs.getString("JUSTIFICATIF"));
        conge.setStatut(rs.getString("STATUT"));
        return conge;
    }

    // Utility to generate a simple unique ID (for testing, not robust for production)
    private String generateUniqueCongeId() {
        return "CON-" + System.currentTimeMillis() % 10000; // Simple example
    }
}